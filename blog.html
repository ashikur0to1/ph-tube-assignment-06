<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blog</title>
    <link href="https://cdn.jsdelivr.net/npm/daisyui@3.6.4/dist/full.css" rel="stylesheet" type="text/css" />
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="container mx-auto">
    <header>
        <h1 class="text-6xl font-semibold text-center mt-5">Some important topics blog of <span class="text-sky-500">Javascript</span></h1>
    </header>
    <main class="mt-12">
        <h2 class="text-2xl text-indigo-500">1. Discuss the scope of var, let, and const</h2><br>
        <article>
            <p>
            <span class="font-semibold">Ans: </span><br><br>
            A lot of shiny new features came out with ES2015 (ES6). And now, since it's 2023, it's assumed that a lot of JavaScript developers have become familiar with and have started using these features.<br> <br>

            While this assumption might be partially true, it's still possible that some of these features remain a mystery to some devs.
            
            One of the features that came with ES6 is the addition of let and const, which can be used for variable declaration. The question is, what makes them different from good ol' var which we've been using? If you are still not clear about this, then this article is for you.
            
            In this article, we'll discuss var, let and const  with respect to their scope, use, and hoisting. As you read, take note of the differences between them that I'll point out.<br><br>
        
            <span class="font-bold">Var</span><br><br>
            Before the advent of ES6, var declarations ruled. There are issues associated with variables declared with var, though. That is why it was necessary for new ways to declare variables to emerge. First, let's get to understand var more before we discuss those issues.<br><br>

            <span class="font-bold">Scope of var</span><br><br>
            Scope essentially means where these variables are available for use. var declarations are globally scoped or function/locally scoped.

            The scope is global when a var variable is declared outside a function. This means that any variable that is declared with var outside a function block is available for use in the whole window.

            var is function scoped when it is declared within a function. This means that it is available and can be accessed only within that function.<br><br>

            <span class="font-bold">var variables can be re-declared and updated</span><br><br>
            This means that we can do this within the same scope and won't get an error.<br><br>

            <span class="font-bold">Hoisting of var</span><br><br>
            Hoisting is a JavaScript mechanism where variables and function declarations are moved to the top of their scope before code execution.<br><br>

            <span class="font-bold">Problem with var</span><br><br>
            If you have used variable declared with var in other parts of your code, you might be surprised at the output you might get. This will likely cause a lot of bugs in your code. This is why let and const are necessary.<br><br>

            <span class="font-bold">Let</span><br><br>
            let is now preferred for variable declaration. It's no surprise as it comes as an improvement to var declarations. It also solves the problem with var that we just covered. Let's consider why this is so.<br><br>

            <span class="font-bold">let is block scoped</span><br><br>
            A block is a chunk of code bounded by {}. A block lives in curly braces. Anything within curly braces is a block.<br><br>

            So a variable declared in a block with let  is only available for use within that block.<br><br>

            <span class="font-bold">let can be updated but not re-declared.</span> <br><br>
            Just like var,  a variable declared with let can be updated within its scope. Unlike var, a let variable cannot be re-declared within its scope.<br><br>

            This fact makes let a better choice than var. When using let, you don't have to bother if you have used a name for a variable before as a variable exists only within its scope.<br><br>

            Also, since a variable cannot be declared more than once within a scope, then the problem discussed earlier that occurs with var does not happen.<br><br>

            <span class="font-bold">Hoisting of let</span><br><br>
            Just like  var, let declarations are hoisted to the top. Unlike var which is initialized as undefined, the let keyword is not initialized. So if you try to use a let variable before declaration, you'll get a Reference Error.<br><br>

            <span class="font-bold">Const</span><br><br>
            Variables declared with the const maintain constant values. const declarations share some similarities with let declarations.<br><br>

            <span class="font-bold">const declarations are block scoped</span><br><br>
            Like let declarations, const declarations can only be accessed within the block they were declared.<br><br>

            <span class="font-bold">const cannot be updated or re-declared</span><br><br>
            This means that the value of a variable declared with const remains the same within its scope. It cannot be updated or re-declared.<br><br>

            Every const declaration, therefore, must be initialized at the time of declaration.<br><br>

            This behavior is somehow different when it comes to objects declared with const. While a const object cannot be updated, the properties of this objects can be updated.<br><br>

            <span class="font-bold">Hoisting of const</span><br><br>
            Just like let, const declarations are hoisted to the top but are not initialized.<br><br>

            So just in case you missed the differences, here they are :<br><br>

            1. var declarations are globally scoped or function scoped while let and const are block scoped.<br><br>

            2. var variables can be updated and re-declared within its scope; let variables can be updated but not re-declared; const variables can neither be updated nor re-declared.<br><br>

            3. They are all hoisted to the top of their scope. But while var variables are initialized with undefined, let and const variables are not initialized.<br><br>

            4. While var and let can be declared without being initialized, const must be initialized during declaration.<br><br>
            </p>
        </article>

        <h2 class="text-2xl text-indigo-500">2. Tell us the use cases of null and undefined</h2><br>

        <article>
            <p>
                <span class="font-bold">Ans: </span><br><br>
                <span class="font-bold">Overview</span><br><br>
                Null in JavaScript means an empty value and is also a primitive type in JavaScript. The variable which has been assigned as null contains no value. Undefined, on the other hand, means the variable has been declared, but its value has not been assigned.<br><br>

                <span class="font-bold">What is Null?</span><br><br>
                We have heard the word "null" many times in English. Its literal meaning is having no value. The same meaning is analogous to the meaning of null in programming.<br><br>

                Null is basically an assignment value given to a variable. The variable which has been assigned as null contains no value.<br><br>

                When we assign null as a value to any variable, it means that it is empty or blank. It is to show that the variable has no value. Also, null is an object in JavaScript. When it gets assigned to a variable, it represents no value. The setting of the value must be done manually by the user as JavaScript never sets the value as null. An object can be emptied by setting it to null.<br><br>

                <span class="font-bold">What is Undefined?</span><br><br>
                There is a subtle difference between null and undefined, but as a programmer, it is important that we understand it clearly.<br><br>

                As the name suggests, undefined means "not defined". So we declare a variable but do not assign a value to it, the variable becomes undefined.<br><br>

                Unlike null, the value of an undefined variable is set by JavaScript as undefined. The variable gets created at the run-time. When we do not pass an argument for a function parameter, the default value is taken as undefined. Besides, when a function doesn't return a value, it returns undefined.<br><br>

                <span class="font-bold">Conclusion</span><br><br>
                Null is basically an assignment value. The variable which has been assigned as null contains no value and is empty.<br><br>
                Undefined is when we declare a variable but do not assign a value to it(define it), the variable becomes undefined.<br><br>
                Null is a type of object.<br><br>
                The data type of undefined is undefined.<br><br>
                When we perform arithmetic operations on null, the value gets converted to 0, and then the further operations get performed.<br><br> When we perform arithmetic operations on undefined, it prints NaN as the value is undefined and not a number.<br><br>
            </p>
        </article>

        <h2 class="text-2xl text-indigo-500">3. What do you mean by REST API?</h2><br>

        <article>
            <p>
                <span class="font-semibold">Ans: </span><br><br>
                An API, or application programming interface, is a set of rules that define how applications or devices can connect to and communicate with each other. A REST API is an API that conforms to the design principles of the REST, or representational state transfer architectural style. For this reason, REST APIs are sometimes referred to RESTful APIs.<br><br>

                First defined in 2000 by computer scientist Dr. Roy Fielding in his doctoral dissertation, REST provides a relatively high level of flexibility and freedom for developers. This flexibility is just one reason why REST APIs have emerged as a common method for connecting components and applications in a microservices architecture.<br><br>

                <span class="font-bold">REST design principles</span><br><br>
                At the most basic level, an API is a mechanism that enables an application or service to access a resource within another application or service. The application or service doing the accessing is called the client, and the application or service containing the resource is called the server.<br><br>

                Some APIs, such as SOAP or XML-RPC, impose a strict framework on developers. But REST APIs can be developed using virtually any programming language and support a variety of data formats. The only requirement is that they align to the following six REST design principles - also known as architectural constraints:<br><br>

                1. <span class="font-bold">Uniform interface:</span> All API requests for the same resource should look the same, no matter where the request comes from. The REST API should ensure that the same piece of data, such as the name or email address of a user, belongs to only one uniform resource identifier (URI). Resources shouldn't be too large but should contain every piece of information that the client might need.<br><br>

                2. <span class="font-bold">Client-server decoupling:</span> In REST API design, client and server applications must be completely independent of each other. The only information the client application should know is the URI of the requested resource; it can't interact with the server application in any other ways. Similarly, a server application shouldn't modify the client application other than passing it to the requested data via HTTP.<br><br>

                3. <span class="font-bold">Statelessness:</span> REST APIs are stateless, meaning that each request needs to include all the information necessary for processing it. In other words, REST APIs do not require any server-side sessions. Server applications aren't allowed to store any data related to a client request.<br><br>

                4. <span class="font-bold">Cacheability:</span> When possible, resources should be cacheable on the client or server side. Server responses also need to contain information about whether caching is allowed for the delivered resource. The goal is to improve performance on the client side, while increasing scalability on the server side.<br><br>

                5. <span class="font-bold">Layered system architecture:</span> In REST APIs, the calls and responses go through different layers. As a rule of thumb, don't assume that the client and server applications connect directly to each other. There may be a number of different intermediaries in the communication loop. REST APIs need to be designed so that neither the client nor the server can tell whether it communicates with the end application or an intermediary.<br><br>

                6. <span class="font-bold">Code on demand (optional):</span> REST APIs usually send static resources, but in certain cases, responses can also contain executable code (such as Java applets). In these cases, the code should only run on-demand.<br><br>

                <span class="font-bold">How REST APIs work:</span><br><br>
                REST APIs communicate via HTTP requests to perform standard database functions like creating, reading, updating, and deleting records (also known as CRUD) within a resource. For example, a REST API would use a GET request to retrieve a record, a POST request to create one, a PUT request to update a record, and a DELETE request to delete one. All HTTP methods can be used in API calls. A well-designed REST API is similar to a website running in a web browser with built-in HTTP functionality.<br><br>

                The state of a resource at any particular instant, or timestamp, is known as the resource representation. This information can be delivered to a client in virtually any format including JavaScript Object Notation (JSON), HTML, XLT, Python, PHP, or plain text. JSON is popular because it's readable by both humans and machines—and it is programming language-agnostic.<br><br>

                Request headers and parameters are also important in REST API calls because they include important identifier information such as metadata, authorizations, uniform resource identifiers (URIs), caching, cookies and more. Request headers and response headers, along with conventional HTTP status codes, are used within well-designed REST APIs.<br><br>

                <span class="font-bold">REST API best practices:</span><br><br>
                Although flexibility is a big advantage of REST API design, that same flexibility makes it easy to design an API that’s broken or performs poorly. For this reason, professional developers share best practices in REST API specifications.<br><br>

                The OpenAPI Specification (OAS) establishes an interface for describing an API in a way that allows any developer or application to discover it and fully understand its parameters and capabilities - available endpoints, allowed operations on each endpoint, operation parameters, authentication methods, and other information. The latest version, OAS3 (link resides outside ibm.com), includes with hands-on tools, such as the OpenAPI Generator, for generating API clients and server stubs in different programming languages.<br><br>

                Securing a REST API also starts with industry best practices, such as using hashing algorithms for password security and HTTPS for secure data transmission. An authorization framework like OAuth 2.0 (link resides outside ibm.com) can help limit the privileges of third-party applications. Using a timestamp in the HTTP header, an API can also reject any request that arrives after a certain time period. Parameter validation and JSON Web Tokens are other ways to ensure that only authorized clients can access the API.<br><br>
            </p>
        </article>
    </main>
</body>
</html>